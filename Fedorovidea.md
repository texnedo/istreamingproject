# Задача набрать статистику по потерям, задержкам и битым пакетам(а так же группам пакетов) в зависимости от времени... #

От нас требуется написать программы которые будут обмениваться высокоуровневыми пакетами через реальный интернет и собирать статистику.

# Что получилось выяснить: #
Внешний пинг естественно не проходит, поскольку мы просто посылаем на адрес всей подсети http://ping.eu/.

http://en.wikipedia.org/wiki/Port_address_translation - как это сделано в обычной сети провайдера.

Так или иначе внешний мир не может узнать, что я включил свой комп, пока комп сам куда-нибудь не постучится и сообщит внешнему серверу об этом.

Получается что когда комп с нелегальным ip посылает запрос на сервак при кождом прохождении через роутер заменяется адрес и порт в пакете(создается запись - такой-то комп запросил такой-то адрес).

Позволяет предотвратить или ограничить обращение снаружи ко внутренним хостам, оставляя возможность обращения изнутри наружу. При инициации соединения изнутри сети создаётся трансляция. Ответные пакеты, поступающие снаружи, соответствуют созданной трансляции и поэтому пропускаются. Если для пакетов, поступающих снаружи, соответствующей трансляции не существует (а она может быть созданной при инициации соединения или статической), они не пропускаются.

http://en.wikipedia.org/wiki/Hamachi_%28software%29   - может нам попробовать замутить VPN и через него гонять пакеты.
http://en.wikipedia.org/wiki/OpenVPN

Однако проблема такого впн, что он и будет узким местом системы - поэтому на такой вариант забиваем.
## Вывод: Катит только если обмениваться с компом у которого есть белый ip. ##

# Запосы для гуглинга #
# офтоп: удобно искать вот здесь http://citeseerx.ist.psu.edu/

1. internet loss model

2. Modelling Internet End-to-End Loss


http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.20&rep=rep1&type=pdf


# Продолжаем идею о передаче пакетов через интернет #

1. На кафедре стоит сервер с 2003 который имеет белый ip - с него делаем форвардинг на сервер с debian, на котором и будет установлена клиентская часть программы.

2. Будем пытаться передать пакеты RTP/RTCP/RTSP используя готовый компонент live555 http://www.live555.com/liveMedia/#testProgs.

3. Каждый пакет на время тестирования должен иметь свой ID. Синхронизируем время и записываем время отправки на сервере и время приема на клиенте в mysql базы. Надо разобраться как можно приложить к пакетам с реальными данными метаданные содержащие его ID либо придумать другой метод идентификации пакетов.

4. Таким образом можно будет потом вычислить прошел ли пакет, с какой задержкой прошел и поскольку номера(ID) идут последовательно можно будет посчитать группу(_burst errors_).

# Собираем live555 #

1. На винде собрать его в mingwhttp://www.mingw.org/ не получилось, поскольку нету комманды cc - обычного сишного компилятора.

2. На убунте все собралось по мануалу http://www.live555.com/liveMedia/#testProgs.

3. Затем скачал несколько примеров файлов mpeg2 и mpeg4.

4. Пересобрал testMPEG1or2VideoStreamer - читает mpeg2 и стримит его, прочитать поток можно если запустить testMPEG1or2VideoReceiver. Плюсы: есть клиент и север - можно модифицировать и того и другого. Проверял - все работатет.

5. testMPEG4VideoStreamer - вот эта штука стримит четверку, причем поток можно открыть к браузере.

6. Единственная трабла, что live555 на данный момент не поддерживает ipv6.

7. После танцев с бубном вокруг NetBeanshttp://cnd.netbeans.org/cnd-tutorial.html(настройка путей к компиляторам G++ и GCC) оказалось что можно импортировать в среду проекты у которых есть готовые make файлы. Собственно я залодил в проект весь live555.

8. В ресивере найдено место где вызывается бесконечный цикл - `env->taskScheduler().doEventLoop();`
который вызывает
`void BasicTaskScheduler::SingleStep(unsigned maxDelayTime){`} из файла

_/home/kvant/Downloads/live/BasicUsageEnvironment/BasicTaskScheduler.cpp_

9. Задача: разобраться в этой функции и понять где она читает данные из сокетов - в это место мы добавим процедурку логирования пришедших пакетов.

10.  `(*handler->handlerProc)(handler->clientData, resultConditionSet);`
-BasicUsageEnvironment.cpp
Таким образом мы передаем сюда функцию, которая обрабатывает полученые результаты из сокетов. Надо раскопать это глубже.

11. `u_int32_t tsNow = convertToRTPTimestamp(timeNow);` - RTCPSink.cpp - похоже, что это то что нужно: пробуем поставить здесь вывод на экран

12. `double timeNow = dTimeNow();` - RTCP.cpp - похоже на вычисление времени для таймстемпа

13. Надо курить ману http://www.live555.com/liveMedia/faq.html

14. Разбираем как идут вызовы из стриммера:

videoSink = MPEG1or2VideoRTPSink::createNew(**env, &rtpGroupsock);**

VideoRTPSink

MultiFramedRTPSink(env, rtpgs, rtpPayloadType, rtpTimestampFrequency,
> rtpPayloadFormatName)
MultiFramedRTPSink


# Забиваем на live555 #

Отсутствие хоть какой-то документации и возможности отладки тестовых программ сделали свое дело и я решил, что надо поменять вектор работы.

# ustat #
Прога для сканирования статистики на пакетах UDP. Пишет статистику в текстовые файлы на клиенте и на сервере(в архиве есть примеры файлов с логами).
Качаем: http://istreamingproject.googlecode.com/files/ustat_2.1.zip